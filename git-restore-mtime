#!/usr/bin/env python3
#
# git-restore-mtime - Change mtime of files based on commit date of last change
#
#    Copyright (C) 2012 Rodrigo Silva (MestreLion) <linux@rodrigosilva.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program. See <http://www.gnu.org/licenses/gpl.html>
#
# Change the modification time (mtime) of all files in work tree, based on the
# date of the most recent commit that modified the file.
#
# Useful prior to generating release tarballs, so each file is archived with a
# date that is similar to the date when the file was actually last modified,
# assuming the actual modification date and its commit date are close.

# By default ignores all ignored and untracked files, and also refuses to work
# on trees with uncommitted changes.

if __name__ != "__main__":
    raise ImportError("%s should not be used as a module." % __name__)

import subprocess, shlex
import sys, os.path
import logging as logger
import argparse
import time


# Command-line interface ######################################################

parser = argparse.ArgumentParser(
    description='Restore original modification time of files based on '
                'the date of the most recent commit that modified them. '
                'Useful when generating release tarballs.')

parser.add_argument('--quiet', '-q',
                    action="store_true",
                    help='suppress informative messages and summary statistics.')

parser.add_argument('--verbose', '-v',
                    action="store_true",
                    help='print additional information for each processed file. '
                    'Overrides --quiet.')

parser.add_argument('--force', '-f',
                    action="store_true",
                    help='force execution on trees with uncommitted changes.')

parser.add_argument('--merge', '-m',
                    action="store_true",
                    help='include merge commits. Leads to more recent mtimes '
                        'and more files per commit, thus with the same mtime '
                        '(which may or may not be what you want). Including '
                        'merge commits may lead to less commits being evaluated '
                        '(all files are found sooner), which improves performance, '
                        'sometimes substantially. But since merge commits are '
                        'usually huge, processing them may also take longer, '
                        'sometimes substantially. By default merge logs are only '
                        'used for files missing from regular commit logs.')

parser.add_argument('--first-parent',
                    action="store_true",
                    help='pass --first-parent to git whatchanged to hide the '
                        'second parent from the merge commit logs. Only has any '
                        'effect if --merge is also specified or --skip-missing '
                        'is not specified and there were files not found in regular '
                        'commit logs.')

parser.add_argument('--skip-missing', '-s',
                    action="store_false", default=True, dest='missing',
                    help='do not try to find missing files. If some files were '
                        'not found in regular commit logs, by default it re-tries '
                        'using merge commit logs for these files (if --merge was '
                        'not used already). This option disables this behavior, '
                        'which may slightly improve performance, but files '
                        'found only in merge commits will not be updated.')

parser.add_argument('--no-directories', '-D',
                    action="store_false", default=True, dest='dirs',
                    help='do not update directory mtime for files created, '
                        'renamed or deleted in it. Note: just modifying a file '
                        'will not update its directory mtime.')

parser.add_argument('--test', '-t',
                    action="store_true", default=False, dest='test',
                    help='test run: do not actually update any file')

parser.add_argument('--commit-time', '-c',
                    action='store_const', const='%ct', default='%at', dest='timeformat',
                    help='use commit time instead of author time')

parser.add_argument('pathspec',
                    nargs='*', default=[os.path.curdir],
                    help='only modify paths (dirs or files) matching PATHSPEC, '
                        'relative to current directory. '
                        'Default is to modify all non-ignored, tracked files.')

parser.add_argument('--work-tree',
                    dest='workdir',
                    help='specify where the work tree is. '
                        'Default for most repositories is current directory.')

parser.add_argument('--git-dir',
                    dest='gitdir',
                    help='specify where the git repository is. '
                        'Default for most repositories <work-tree>/.git')

args = parser.parse_args()

gitcmd = ['git']
if args.workdir: gitcmd.append("--work-tree=%s" % args.workdir)
if args.gitdir : gitcmd.append("--git-dir=%s"   % args.gitdir)

if   args.verbose: level = logger.DEBUG
elif args.quiet:   level = logger.WARN
else:              level = logger.INFO

logger.basicConfig(level=level, format='%(message)s')


# Helper functions #########################################################

def normalize(path):
    """Normalize paths from git, handling non-ASCII characters.

    Git for Windows, as of v1.7.10, stores paths as UTF-8 normalization form C. If path
    contains non-ASCII or non-printable chars it outputs the UTF-8 in octal-escaped
    notation, double-quoting the whole path. Double-quotes and backslashes are also escaped.

    https://git-scm.com/docs/git-config#Documentation/git-config.txt-corequotePath
    https://github.com/msysgit/msysgit/wiki/Git-for-Windows-Unicode-Support
    https://github.com/git/git/blob/master/Documentation/i18n.txt

    Example on git output, this function reverts this:
    r'back\slash_double"quote_açaí' -> r'"back\\slash_double\"quote_a\303\247a\303\255"'
    """
    if path.startswith('"'):
        # Python 2: path = path[1:-1].decode("string-escape")
        # Python 3: https://stackoverflow.com/a/46650050/624066
        path = (path[1:-1]                 # Remove enclosing double quotes
                .encode('latin1')          # Convert to bytes, required 'unicode-escape'
                .decode('unicode-escape')  # Perform the actual octal-escaping decode
                .encode('latin1')          # 1:1 mapping to bytes, forming UTF-8 encoding
                .decode('utf8'))           # Decode from UTF-8
    # Make sure the slash matches the OS; for Windows we need a backslash
    return os.path.normpath(path)


def touch(path, mtime, test=False):
    """The actual mtime update"""
    if test: return
    os.utime(path, (mtime, mtime), follow_symlinks=False)


def git_ls_files(pathspec, gitcmd):
    gitobj = subprocess.Popen(gitcmd + shlex.split('ls-files --full-name') +
                              ['--'] + pathspec,
                              stdout=subprocess.PIPE, universal_newlines=True)
    for line in gitobj.stdout:
        yield normalize(line.strip())


# Main Logic ##################################################################

# UI done, it's show time!
start = time.time()  # yes, Wall time. CPU time is not realistic for users.

loglines = commits = touches = errors = dirtouches = direrrors = 0
stepmissing = 100


# First things first: Where and Who are we?
try:
    workdir, gitdir = subprocess.check_output(gitcmd + shlex.split(
                    'rev-parse --show-toplevel --git-dir'),
                    universal_newlines=True).split('\n')[:2]

    workdir = os.path.abspath(workdir)
    gitdir  = os.path.abspath(gitdir)

except subprocess.CalledProcessError as e:
    # rev-parse couldn't find git repo, and already informed user.
    # So we just...
    sys.exit(e.returncode)


# Get the files managed by git
lsfileslist = set(git_ls_files(args.pathspec, gitcmd))

# List files matching user pathspec, relative to current directory
# git commands always print paths relative to work tree root
filelist = set()
dirlist  = set()
update_symlinks = bool(os.utime in getattr(os, 'supports_follow_symlinks', []))
for path in args.pathspec:

    # Normalize user input so ./doc = doc/ = doc/../doc/. = doc
    path = os.path.normpath(path)

    # Is path inside the work tree?
    if os.path.commonprefix([workdir, os.path.abspath(path)]) != workdir:
        logger.warn("WARNING: Skipping pathspec outside work tree: %s", path)
        continue

    # git does not care if it's a broken symlink, hence lexists
    if not os.path.lexists(path):
        logger.warn("WARNING: Skipping non-existing pathspec: %s", path)
        continue

    # file or symlink (to file, to dir or broken - git handles the same way)
    islink = os.path.islink(path)
    if os.path.isfile(path) or islink:
        if islink and not update_symlinks:
            logger.warn("WARNING: Skipping symlink, OS does not support update: %s", path)
            continue
        # Always add them relative to worktree root
        filelist.add(os.path.relpath(path, workdir))

    # dir
    else:
        for root, subdirs, files in os.walk(path):
            if gitdir in [os.path.abspath(os.path.join(root, subdir))
                          for subdir in subdirs]:
                subdirs.remove(os.path.basename(gitdir))

            if os.path.abspath(root) == workdir and '.git' in files:
                files.remove('.git')

            if args.dirs:
                dirname = os.path.relpath(root, workdir)
                if dirname == '.':
                    dirname = ''  # Like git does
                dirlist.add(dirname)

            for file in files:
                # Always add them relative to worktree root
                filelist.add(os.path.relpath(os.path.join(root, file), workdir))

filelist &= lsfileslist

totalfiles = files = len(filelist)
logger.info("{0:,} files to be processed in work dir".format(totalfiles))


# Discard untracked and ignored files
ignoredlist = set()
gitobj = subprocess.Popen(gitcmd + shlex.split('status --porcelain --ignored') +
                          ['--'] + args.pathspec,
                          stdout=subprocess.PIPE, universal_newlines=True)
for line in gitobj.stdout:
    line = line.strip()
    status = line[:2]
    filespec = line[3:]

    # Make sure the slash matches the OS; for Windows we need a backslash
    filespec = os.path.normpath(filespec)

    if status in ('??', '!!'):  # also safe to ignore: 'A ', ' M'
        # filespec can be a dir, so we must iterate on filelist
        for file in filelist:
            if (
                (filespec.endswith(os.sep) and file.startswith(filespec))
                or (file == filespec)
            ):
                logger.debug("Ignoring: %s", file)
                ignoredlist.add(file)
    elif not args.force:
        logger.critical(
         "ERROR: There are local changes in the working directory.\n"
         "This could lead to undesirable results for modified files.\n"
         "Please, commit your changes (or use --force) and try again.\n"
         "Aborting")
        gitobj.kill()
        sys.exit(1)

if ignoredlist:
    filelist -= ignoredlist
    files = len(filelist)
    logger.info("{:,} files to process after ignoring {:,}"
                "".format(files, len(ignoredlist)))


# Process the log until all files are 'touched'
logger.debug("Line #\tLog #\tFiles\tmtime\tFile")
def parselog(merge=False, filterlist=[]):
    global loglines, commits, touches, errors, dirtouches, direrrors, files

    gitobj = subprocess.Popen(gitcmd + shlex.split('whatchanged --pretty={}'.format(args.timeformat)) +
                              (['-m'] if merge else []) +
                              (['--first-parent'] if args.first_parent else []) +
                              ['--'] + filterlist,
                              stdout=subprocess.PIPE, universal_newlines=True)
    mtime = 0
    for line in gitobj.stdout:
        loglines += 1
        line = line.strip()

        # Blank line between Date and list of files
        if not line: continue

        # File line
        if line.startswith(':'):
            # If line describes a rename, linetok has three tokens, otherwise
            # two.
            linetok = line.split('\t')
            status = linetok[0]
            file = linetok[-1]

            # Handles non-ASCII chars and OS path separator
            file = normalize(file)

            if file in filelist:
                logger.debug("%d\t%d\t%d\t%s\t%s",
                             loglines, commits, files,
                             time.ctime(mtime), file)
                filelist.remove(file)
                files -= 1
                try:
                    touch(os.path.join(workdir, file), mtime, args.test)
                    touches += 1
                except Exception as e:
                    logger.error("ERROR: %s", e)
                    errors += 1

            if args.dirs:
                dirname = os.path.dirname(file)
                if status[-1] in ('A', 'D') and dirname in dirlist:
                    logger.debug("%d\t%d\t-\t%s\t%s",
                                 loglines, commits,
                                 time.ctime(mtime), "{}/".format(dirname or '.'))
                    dirlist.remove(dirname)
                    try:
                        touch(os.path.join(workdir, dirname), mtime, args.test)
                        dirtouches += 1
                    except Exception as e:
                        logger.error("ERROR: %s", e)
                        direrrors += 1

        # Date line
        else:
            commits += 1
            mtime = int(line)

        # All files done?
        if not files:
            break

    try:
        gitobj.terminate()
    except OSError:
        pass


parselog(args.merge, args.pathspec)

# Missing files
if filelist:

    # Try to find them in merge logs, if not done already
    # (usually HUGE, thus MUCH slower!)
    if args.missing and not args.merge:
        filterlist = list(filelist)
        for i in range(0, len(filterlist), stepmissing):
            parselog(merge=True, filterlist=filterlist[i:i+stepmissing])

    # Still missing some?
    for file in filelist:
        logger.warn("WARNING: not found in log: %s", file)


# Final statistics
# TODO: use git-log --before=mtime to brag about skipped log entries
logger.info(
    "Statistics:\n"
    "{:13,.2f} seconds\n"
    "{:13,} log lines processed\n"
    "{:13,} commits evaluated"
    "".format(time.time()-start, loglines, commits))

if args.dirs:
    if direrrors: logger.info("{:13,} directory update errors".format(direrrors))
    logger.info("{:13,} directories updated".format(dirtouches))

if touches != totalfiles: logger.info("{:13,} files".format(totalfiles))
if ignoredlist:           logger.info("{:13,} files ignored".format(len(ignoredlist)))
if files:                 logger.info("{:13,} files missing".format(files))
if errors:                logger.info("{:13,} file update errors".format(errors))

logger.info("{:13,} files updated".format(touches))

if args.test:
        logger.info("TEST RUN - No files modified!")

# Statistics for some large projects

#bash
#         0.27 seconds
#        5,750 log lines processed
#           62 commits evaluated
#        1,155 updated files

#git
#         3.71 seconds
#       96,702 log lines processed
#       24,217 commits evaluated
#        2,495 updated files

#git (--merge)
#         0.19 seconds
#        2,586 log lines processed
#            3 commits evaluated
#        2,495 updated files

#wine
#        13.53 seconds
#      443,979 log lines processed
#       91,703 commits evaluated
#        6,005 updated files

#linux kernel
#        59.11 seconds
#    1,484,567 log lines processed
#      313,164 commits evaluated
#       40,902 updated files

#linux kernel (--skip-missing)
#WARNING: not found in log: arch/arm/mach-sa1100/include/mach/reset.h
#WARNING: not found in log: lib/raid6/unroll.awk
#Statistics:
#        51.88 seconds
#    1,484,558 log lines processed
#      313,161 commits evaluated
#       40,902 total files
#            2 missing files
#       40,900 updated files

#linux kernel (--merge)
#       501.17 seconds
#   34,495,300 log lines processed
#      238,711 commits evaluated
#       40,902 updated files
